{"question": "What architectural trade-offs are involved when the StatelessAnnotated class is wrapped by AnnotatedTypeWrapper in the CDI module's integration with Apache Shiro's security layer?","answer": "I found the CDI wrapper and extension classes plus the related test containing StatelessAnnotated. I'll quote only the critical lines and then answer concisely. - In short: wrapping a Stateless EJB’s annotated type lets CDI inject Shiro’s security semantics without altering the bean’s source, but it introduces metadata indirection, interceptor/proxy layering, and lifecycle/ordering concerns between EJB and CDI.\n\nKey points with code references:\n- Wrapper-based metadata rewriting\n  - AnnotatedTypeWrapper delegates all AnnotatedType methods while replacing the effective annotation set, optionally keeping or removing originals and adding new ones.\n```java\npublic AnnotatedTypeWrapper(AnnotatedType<T> wrapped, boolean keepOriginalAnnotations,\n                            Set<Annotation> additionalAnnotations, Set<Annotation> annotationsToRemove) {\n    this.wrapped = wrapped;\n    Stream.Builder<Annotation> builder = Stream.builder();\n    if (keepOriginalAnnotations) {\n        var annotationTypesToExclude = annotationsToRemove.stream()\n                .map(AnnotatedTypeWrapper::checkIfAnnotation)\n                .map(Annotation::annotationType).collect(Collectors.toSet());\n        wrapped.getAnnotations().stream().filter(ann ->\n                        !annotationTypesToExclude.contains(ann.annotationType()))\n                .forEach(builder::add);\n    }\n    additionalAnnotations.forEach(annotation -> addToBuilder(builder, annotation));\n    annotations = builder.build().collect(Collectors.toSet());\n}\n```\n  - Trade-off: flexible, non-invasive integration vs. risk of diverging CDI/EJB views of annotations, plus a small reflection/stream overhead on startup and potential surprises for frameworks that introspect original annotations.\n\n- Shiro binding via CDI extension\n  - The CDI extension applies a marker annotation when Shiro or JSR-250 security annotations are present, using the wrapper to “virtually” add the binding.\n```java\npublic <T> void addSecurity(@Observes @WithAnnotations({\n        RequiresAuthentication.class, RequiresGuest.class, RequiresPermissions.class,\n        RequiresRoles.class, RequiresUser.class, RolesAllowed.class,\n        PermitAll.class, DenyAll.class}) ProcessAnnotatedType<T> pat) {\n    pat.setAnnotatedType(new AnnotatedTypeWrapper<>(pat.getAnnotatedType(),\n            ShiroSecureAnnotated.class.getDeclaredAnnotations()[0]));\n}\n```\n  - Trade-off: consistent interceptor binding without touching user code vs. reliance on CDI lifecycle ordering (must run before EJB/container caches metadata). Misordering can cause missing or duplicated bindings.\n\n- Interactions with @Stateless (EJB)\n  - The test demonstrates wrapping a @Stateless-annotated type and adding security bindings; it can either keep original annotations or replace them.\n```java\n@Stateless\nprivate final class StatelessAnnotated {\n}\n```\n```java\nAnnotation shiroSecureAnnotation = getAnnotation(ShiroSecureAnnotated.class, ShiroSecureAnnotation.class);\nAnnotation statelessAnnotation = getAnnotation(StatelessAnnotated.class, Stateless.class);\nvar wrapper = new AnnotatedTypeWrapper<>(annotatedType, shiroSecureAnnotation, statelessAnnotation);\nassertTrue(wrapper.isAnnotationPresent(Stateless.class));\n```\n```java\nvar wrapper = new AnnotatedTypeWrapper<>(annotatedType, false,\n        Set.of(shiroSecureAnnoations, statelessAnnoations),\n        Set.of());\nassertTrue(wrapper.isAnnotationPresent(Stateless.class));\n```\n  - Trade-offs:\n    - Pros: preserve Stateless EJB semantics while layering Shiro interceptors; no source changes; centralized enablement.\n    - Cons: possible tension between EJB container lifecycle/concurrency rules and CDI proxy/interceptor chains; need to avoid introducing incompatible scopes (e.g., session-scoped security context) onto a stateless bean; must ensure wrapper does not strip or shadow @Stateless inadvertently; debugging becomes harder because effective annotations differ from the original class.\n\n- Performance and maintainability\n  - The wrapper’s stream/collection composition happens during type processing, generally one-time per bean, but adds minor startup cost.\n  - Delegation (@Delegate) keeps behavior transparent for other AnnotatedType methods, but increases indirection and test surface.\n```java\nprivate final @Delegate(types = AT.class) AnnotatedType<T> wrapped;\nprivate final @Getter Set<Annotation> annotations;\n```\n\nNet effect:\n- Benefits: decoupled, configurable security binding; works with both Shiro and JSR-250 annotations; preserves original bean class.\n- Risks: lifecycle ordering pitfalls, scope/semantics mismatch for stateless beans, and metadata opacity that can affect other extensions or EJB tooling.\n\nI examined the CDI wrapper, the extension that applies it, and the tests demonstrating wrapping a @Stateless bean and adding security."}
{"question": "What are the side effects introduced by the onInvalidation function when the SessionKey represents an HTTP session versus a non-HTTP session?","answer": "- HTTP SessionKey:\n  - Removes the request attribute marking the referenced ID as valid.\n  - Removes the session ID cookie.\n  - Emits a debug log about cookie removal.\n```java\nprivate void onInvalidation(SessionKey key) {\n    ServletRequest request = WebUtils.getRequest(key);\n    if (request != null) {\n        request.removeAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID);\n    }\n    if (WebUtils.isHttp(key)) {\n        LOGGER.debug(\"Referenced session was invalid.  Removing session ID cookie.\");\n        removeSessionIdCookie(WebUtils.getHttpRequest(key), WebUtils.getHttpResponse(key));\n    } else {\n        LOGGER.debug(\"SessionKey argument is not HTTP compatible or does not have an HTTP request/response \"\n                + \"pair. Session ID cookie will not be removed due to invalidated session.\");\n    }\n}\n```\n\n- Non-HTTP SessionKey:\n  - Only removes the request attribute (if a request exists); no cookie removal.\n  - Emits a debug log explaining no cookie removal.\n\nContext for the attribute being set earlier during ID resolution:\n```java\nif (id != null) {\n    request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, id);\n    request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE);\n}\n```"}
{"question": "What transitive dependencies on the backingMap field must be analyzed to determine the full impact of invoking the clear method in MapContext across all modules that rely on MapContext state?","answer": "I traced `MapContext` usage and where its state is read/propagated. Clearing its `backingMap` removes all context keys and affects downstream resolvers and factories that depend on them.\n\n- Core container of state\n  - `backingMap` and `clear()` (everything stored via `put/nullSafePut` is wiped):\n```java\nprivate final Map<String, Object> backingMap;\npublic MapContext() {\n    this.backingMap = new HashMap<String, Object>();\n}\npublic void clear() {\n    backingMap.clear();\n}\n```\n\n- SubjectContext: resolution heuristics that rely on map entries\n  - Keys cleared: `SECURITY_MANAGER`, `SESSION_ID`, `SUBJECT`, `PRINCIPALS`, `SESSION`, `AUTHENTICATED`, `HOST`, `AUTHENTICATION_TOKEN`, `AUTHENTICATION_INFO`.\n```java\nprivate static final String SECURITY_MANAGER = DefaultSubjectContext.class.getName() + \".SECURITY_MANAGER\";\nprivate static final String SESSION_ID = DefaultSubjectContext.class.getName() + \".SESSION_ID\";\nprivate static final String SUBJECT = DefaultSubjectContext.class.getName() + \".SUBJECT\";\nprivate static final String PRINCIPALS = DefaultSubjectContext.class.getName() + \".PRINCIPALS\";\nprivate static final String SESSION = DefaultSubjectContext.class.getName() + \".SESSION\";\nprivate static final String AUTHENTICATED = DefaultSubjectContext.class.getName() + \".AUTHENTICATED\";\nprivate static final String HOST = DefaultSubjectContext.class.getName() + \".HOST\";\n```\n  - Resolvers will fall back (SecurityUtils, Subject, Session, RememberMe) when map is empty:\n```java\npublic SecurityManager resolveSecurityManager() {\n    SecurityManager securityManager = getSecurityManager();\n    if (securityManager == null) {\n        // fallback to SecurityUtils.getSecurityManager()\n    }\n    return securityManager;\n}\n```\n```java\npublic PrincipalCollection resolvePrincipals() {\n    PrincipalCollection principals = getPrincipals();\n    if (isEmpty(principals)) { AuthenticationInfo info = getAuthenticationInfo(); }\n    if (isEmpty(principals)) { Subject subject = getSubject(); }\n    if (isEmpty(principals)) { Session session = resolveSession(); }\n    return principals;\n}\n```\n```java\npublic boolean resolveAuthenticated() {\n    Boolean authc = getTypedValue(AUTHENTICATED, Boolean.class);\n    if (!authc) {\n        Session session = resolveSession();\n        if (session != null) { /* read AUTHENTICATED_SESSION_KEY */ }\n    }\n    return authc;\n}\n```\n\n- Subject construction pipeline: copying and propagation\n  - `DefaultSecurityManager.copy` creates a new `DefaultSubjectContext(subjectContext)`, which copies the original map into a new `MapContext`; if the source was cleared earlier, nothing is copied.\n```java\nprotected SubjectContext copy(SubjectContext subjectContext) {\n    return new DefaultSubjectContext(subjectContext);\n}\npublic MapContext(Map<String, Object> map) {\n    this();\n    if (!CollectionUtils.isEmpty(map)) {\n        this.backingMap.putAll(map);\n    }\n}\n```\n  - `createSessionContext` bulk-copies the subject context first; clearing earlier prevents host/sessionId from being carried via `putAll`, and later setters rely on `resolveHost()` which itself uses map or fallbacks.\n```java\nDefaultSessionContext sessionContext = new DefaultSessionContext();\nif (!CollectionUtils.isEmpty(subjectContext)) {\n    sessionContext.putAll(subjectContext);\n}\nSerializable sessionId = subjectContext.getSessionId();\nif (sessionId != null) { sessionContext.setSessionId(sessionId); }\nString host = subjectContext.resolveHost();\nif (host != null) { sessionContext.setHost(host); }\n```\n\n- SubjectFactory consumption of resolved values\n  - If the map is cleared, all values come from resolvers; can yield anonymous or session-less subjects depending on configuration.\n```java\nSecurityManager securityManager = context.resolveSecurityManager();\nSession session = context.resolveSession();\nboolean sessionCreationEnabled = context.isSessionCreationEnabled();\nPrincipalCollection principals = context.resolvePrincipals();\nboolean authenticated = context.resolveAuthenticated();\nString host = context.resolveHost();\n```\n\n- Web module: extra transitive dependencies stored in the same map\n  - Clearing removes `SERVLET_REQUEST` / `SERVLET_RESPONSE`, degrading host and session creation behavior for web subjects.\n```java\nprivate static final String SERVLET_REQUEST = DefaultWebSubjectContext.class.getName() + \".SERVLET_REQUEST\";\nprivate static final String SERVLET_RESPONSE = DefaultWebSubjectContext.class.getName() + \".SERVLET_RESPONSE\";\npublic DefaultWebSubjectContext(WebSubjectContext context) { super(context); }\n```\n```java\npublic String resolveHost() {\n    String host = super.resolveHost();\n    if (host == null) {\n        ServletRequest request = resolveServletRequest();\n        if (request != null) { host = request.getRemoteHost(); }\n    }\n    return host;\n}\n```\n```java\npublic ServletRequest getServletRequest() { return getTypedValue(SERVLET_REQUEST, ServletRequest.class); }\npublic void setServletRequest(ServletRequest request) {\n    if (request != null) { put(SERVLET_REQUEST, request); }\n}\n```\n\n- Type-safety and views\n  - After `clear`, `getTypedValue` returns null (or would have thrown before on type mismatch):\n```java\nprotected <E> E getTypedValue(String key, Class<E> type) {\n    E found = null;\n    Object o = backingMap.get(key);\n    if (o != null) {\n        if (!type.isAssignableFrom(o.getClass())) { throw new IllegalArgumentException(...); }\n        found = (E) o;\n    }\n    return found;\n}\n```\n\nWhat to analyze transitively before invoking `MapContext.clear()`:\n- Core keys/consumers in `DefaultSubjectContext` used by resolvers: security manager, session id, subject, principals, session, authenticated, host, tokens and auth info.\n- Copy/propagation points: `DefaultSecurityManager.copy(...)` and `createSessionContext(...)` `putAll(subjectContext)`.\n- Subject factories that read resolved values: `DefaultSubjectFactory.createSubject(...)` and `DefaultWebSubjectFactory.createSubject(...)`.\n- Web-only context entries: `SERVLET_REQUEST`/`SERVLET_RESPONSE` and `resolveHost()` fallback.\n- Any code reading session attributes as a fallback (e.g., `PRINCIPALS_SESSION_KEY`, `AUTHENTICATED_SESSION_KEY`) because clearing may force those slower/alternate paths.\n\nNet impact: clearing the `backingMap` erases all transient construction inputs; subsequent behavior depends on fallbacks (global `SecurityUtils`, existing `Subject`/`Session`, RememberMe, and web request), which can change identity resolution, authentication flags, host propagation, and session creation across core and web modules."}
{"question": "How does the assertAuthorized function optimize exception handling when processing RequiresRoles annotations with Logical.OR semantics?", "answer": "- For Logical.AND: it directly calls a bulk check that throws once if needed.\n`64:66:/data3/pwh/swebench-repos/java/shiro/core/src/main/java/org/apache/shiro/authz/aop/RoleAnnotationHandler.java\nif (Logical.AND.equals(rrAnnotation.logical())) {\n    getSubject().checkRoles(Arrays.asList(roles));\n    return;\n}\n`\n- For Logical.OR: it first probes with non-throwing hasRole() across all roles, only throwing if none match. This defers exception creation/stack traces and avoids N exceptions in the common “one role matches” case; if no role matches, it throws a single exception via checkRole on the first role.\n`68:79:/data3/pwh/swebench-repos/java/shiro/core/src/main/java/org/apache/shiro/authz/aop/RoleAnnotationHandler.java\nif (Logical.OR.equals(rrAnnotation.logical())) {\n    boolean hasAtLeastOneRole = false;\n    for (String role : roles) {\n        if (getSubject().hasRole(role)) {\n            hasAtLeastOneRole = true;\n        }\n    }\n    if (!hasAtLeastOneRole) {\n        getSubject().checkRole(roles[0]);\n    }\n}\n`\n- Single role shortcut: direct checkRole.\n`60:63:/data3/pwh/swebench-repos/java/shiro/core/src/main/java/org/apache/shiro/authz/aop/RoleAnnotationHandler.java\nif (roles.length == 1) {\n    getSubject().checkRole(roles[0]);\n    return;\n}\n`\n\nNet: it optimizes OR by replacing per-role exception throws with a lightweight boolean scan and one deferred exception, reducing overhead and noisy stack traces when any role suffices."}
{"question": "How does the EventBusAware interface contract enforce lifecycle management when setEventBus is invoked during Spring Boot autoconfiguration in Shiro's web module?", "answer": "- The contract\n  - `EventBusAware` declares a single setter `setEventBus(EventBus bus)`; it does not auto-register subscribers and leaves registration timing to the bean itself.\n`36:44:/data3/pwh/swebench-repos/java/shiro/event/src/main/java/org/apache/shiro/event/EventBusAware.java\npublic interface EventBusAware {\n    void setEventBus(EventBus bus);\n}\n`\n`25:33:/data3/pwh/swebench-repos/java/shiro/event/src/main/java/org/apache/shiro/event/EventBusAware.java\n// NOTE: EventBusAware beans must call eventBus.register(this) themselves if they have @Subscribe methods.\n`\n\n- How Spring Boot autoconfig enforces lifecycle injection\n  - Auto-configures an `EventBus` and installs a `ShiroEventBusBeanPostProcessor` that runs after bean initialization; it injects the bus into any `EventBusAware` bean and, alternatively, auto-registers non-aware beans that merely have `@Subscribe` methods.\n`33:56:/data3/pwh/swebench-repos/java/shiro/support/spring-boot/spring-boot-starter/src/main/java/org/apache/shiro/spring/boot/autoconfigure/ShiroBeanAutoConfiguration.java\n@Configuration\npublic class ShiroBeanAutoConfiguration extends AbstractShiroBeanConfiguration {\n    @Bean protected EventBus eventBus() { return super.eventBus(); }\n    @Bean public ShiroEventBusBeanPostProcessor shiroEventBusAwareBeanPostProcessor() {\n        return super.shiroEventBusAwareBeanPostProcessor();\n    }\n}\n`\n`44:66:/data3/pwh/swebench-repos/java/shiro/support/spring/src/main/java/org/apache/shiro/spring/ShiroEventBusBeanPostProcessor.java\npublic Object postProcessAfterInitialization(Object bean, String beanName) {\n    if (bean instanceof EventBusAware) {\n        ((EventBusAware) bean).setEventBus(eventBus);\n    } else if (isEventSubscriber(bean)) {\n        eventBus.register(bean);\n    }\n    return bean;\n}\n`\n\n- Lifecycle implications for the web module\n  - Injection occurs post-initialization, ensuring the bean’s dependencies are set before it starts publishing/subscribing, avoiding premature event handling during construction.\n  - Beans implementing `EventBusAware` have deterministic access to the bus and retain control over when to register/unregister, improving shutdown/startup symmetry and preventing accidental early event delivery.\n\nNet: Spring Boot wires a shared `EventBus` and invokes `setEventBus` via a BeanPostProcessor after initialization; by contract, aware beans then decide when to register with the bus. This enforces a clear lifecycle phase: construct → initialize → inject bus → optional self-registration, preventing misuse during earlier phases while enabling controlled event participation."}
{"question": "How does the double-checked locking pattern in the JCacheManager getCache method prevent race conditions during concurrent cache initialization while maintaining performance?", "answer": "- First, a non-synchronized read tries to fetch an existing cache; most callers return immediately without locking.\n`73:79:/data3/pwh/swebench-repos/java/shiro/support/jcache/src/main/java/org/apache/shiro/cache/jcache/JCacheManager.java\njavax.cache.Cache<K, V> cache = ensureCacheManager().getCache(name);\nif (cache == null) {\n    synchronized (this) {\n        cache = ensureCacheManager().getCache(name);\n`\n- Inside the synchronized block, it re-checks for null (the second “check” in double-checked locking). Only one thread proceeds to create the cache; others see the published instance and skip creation.\n`79:86:/data3/pwh/swebench-repos/java/shiro/support/jcache/src/main/java/org/apache/shiro/cache/jcache/JCacheManager.java\nif (cache == null) {\n    LOGGER.debug(\"Cache with name '{}' does not yet exist.  Creating now.\", name);\n    cache = ensureCacheManager().createCache(name, new MutableConfiguration<>());\n    LOGGER.debug(\"Added JCache named [{}]\", name);\n} else {\n    LOGGER.debug(\"Using existing JCache named [{}]\", cache.getName());\n}\n`\n- Performance is maintained by avoiding synchronization in the common hit path and only locking on the miss path during initial creation. Race conditions are prevented because creation occurs under the monitor, and the re-read after acquiring the lock observes any cache created by another thread. The returned `Cache` is then wrapped once.\n`90:91:/data3/pwh/swebench-repos/java/shiro/support/jcache/src/main/java/org/apache/shiro/cache/jcache/JCacheManager.java\nreturn new JCache<>(cache);\n`"}
{"question": "What design principle justifies delegating the toString implementation in ObjectPrincipal to the wrapped object rather than providing a custom representation specific to the security context?", "answer": "- Shiro’s JAX-RS bridge wraps a non-Principal primary principal in `ObjectPrincipal`, delegating identity text to the underlying object.\n`100:105:/data3/pwh/swebench-repos/java/shiro/support/jaxrs/src/main/java/org/apache/shiro/web/jaxrs/ShiroSecurityContext.java\npublic String getName() {\n    return getObject().toString();\n}\n`\n`123:125:/data3/pwh/swebench-repos/java/shiro/support/jaxrs/src/main/java/org/apache/shiro/web/jaxrs/ShiroSecurityContext.java\npublic String toString() {\n    return object.toString();\n}\n`\n\n- Design principle: adherence to the Decorator pattern and Liskov Substitution Principle/least surprise. By delegating `toString()` to the wrapped principal, the wrapper preserves the original identity’s representation and behavior, ensuring existing logging and integrations that rely on the principal’s string form remain consistent, instead of introducing a Shiro-specific format."}
{"question": "What performance overhead does conditional debug logging introduce in UnauthorizedExceptionExceptionMapper's toResponse method under high-frequency authorization failure scenarios?", "answer": "- When debug logging is disabled: the overhead is a single boolean check; the message isn’t formatted and the stack trace isn’t captured, so impact is negligible.\n`43:47:/data3/pwh/swebench-repos/java/shiro/support/jaxrs/src/main/java/org/apache/shiro/web/jaxrs/UnauthorizedExceptionExceptionMapper.java\nif (LOG.isDebugEnabled()) {\n    LOG.debug(\"unauthorized.\", exception);\n}\n`\n- When debug logging is enabled: each failure triggers formatting and emission of the exception (including stack trace) to the logging backend, adding CPU and I/O overhead on the request path. Under high frequency, this can meaningfully reduce throughput due to synchronous logging and increased allocation from stack trace handling.\n\n- Net: conditional guard minimizes cost in the common case (debug off); with debug on, expect substantial per-request overhead proportional to log sink performance and exception size."}
{"question": "What is the strategic purpose of the resolveHost method's fallback mechanism in the DefaultWebSubjectContext class within the context of Apache Shiro's web security model?", "answer": "- Strategic purpose: ensure a reliable client host is available for authorization/auditing and session creation even when it wasn’t supplied via token or existing session. If the generic subject context can’t resolve a host, the web context falls back to the HTTP request.\n`49:59:/data3/pwh/swebench-repos/java/shiro/web/src/main/java/org/apache/shiro/web/subject/support/DefaultWebSubjectContext.java\npublic String resolveHost() {\n    String host = super.resolveHost();\n    if (host == null) {\n        ServletRequest request = resolveServletRequest();\n        if (request != null) {\n            host = request.getRemoteHost();\n        }\n    }\n    return host;\n}\n`\n- This complements the generic resolution (token and session fallbacks) so web requests still get a host when those are absent.\n`262:281:/data3/pwh/swebench-repos/java/shiro/core/src/main/java/org/apache/shiro/subject/support/DefaultSubjectContext.java\npublic String resolveHost() {\n    String host = getHost();\n    if (host == null) {\n        AuthenticationToken token = getAuthenticationToken();\n        if (token instanceof HostAuthenticationToken) {\n            host = ((HostAuthenticationToken) token).getHost();\n        }\n    }\n    if (host == null) {\n        Session session = resolveSession();\n        if (session != null) {\n            host = session.getHost();\n        }\n    }\n    return host;\n}\n`\n- Operational impact: the resolved host is propagated into the session context for downstream policies (e.g., IP-aware checks, logging).\n`546:550:/data3/pwh/swebench-repos/java/shiro/core/src/main/java/org/apache/shiro/mgt/DefaultSecurityManager.java\nString host = subjectContext.resolveHost();\nif (host != null) {\n    sessionContext.setHost(host);\n}\n`\n\nIn short: the fallback makes host resolution robust in web flows, decoupling core subject logic from servlet specifics while preserving accurate host data for security decisions."}
{"question": "Where in the codebase is the SecurityManager instance injected into GuiceEnvironment during runtime initialization?", "answer": "- It’s injected via Guice constructor injection in `GuiceEnvironment`:\n`28:31:/data3/pwh/swebench-repos/java/shiro/support/guice/src/main/java/org/apache/shiro/guice/GuiceEnvironment.java\n@Inject\nGuiceEnvironment(SecurityManager securityManager) {\n    this.securityManager = securityManager;\n}\n`\n- For web, `WebGuiceEnvironment` similarly receives a `WebSecurityManager` (a `SecurityManager`) in its injected constructor:\n`41:48:/data3/pwh/swebench-repos/java/shiro/support/guice/src/main/java/org/apache/shiro/guice/web/WebGuiceEnvironment.java\n@Inject\nWebGuiceEnvironment(..., WebSecurityManager securityManager, ...) {\n    this.securityManager = securityManager;\n    ...\n}\n`"}
{"question": "How does the setFilterConfig method in AbstractFilter establish the data dependency chain between FilterConfig and ServletContext during filter initialization?", "answer": "- It sets both the `FilterConfig` and the `ServletContext` in one step, creating an explicit dependency chain: FilterConfig → ServletContext → filter subclass init.\n`66:69:/data3/pwh/swebench-repos/java/shiro/web/src/main/java/org/apache/shiro/web/servlet/AbstractFilter.java\npublic void setFilterConfig(FilterConfig filterConfig) {\n    this.filterConfig = filterConfig;\n    setServletContext(filterConfig.getServletContext());\n}\n`\n- During `init`, it calls `setFilterConfig(...)` and immediately invokes the subclass hook, guaranteeing both are available for initialization.\n`94:101:/data3/pwh/swebench-repos/java/shiro/web/src/main/java/org/apache/shiro/web/servlet/AbstractFilter.java\npublic final void init(FilterConfig filterConfig) throws ServletException {\n    setFilterConfig(filterConfig);\n    try {\n        onFilterConfigSet();\n`\n- Subclasses can then safely read init-params via `getFilterConfig()` and access container resources via `getServletContext()`.\n`79:85:/data3/pwh/swebench-repos/java/shiro/web/src/main/java/org/apache/shiro/web/servlet/AbstractFilter.java\nprotected String getInitParam(String paramName) {\n    FilterConfig config = getFilterConfig();\n    if (config != null) {\n        return StringUtils.clean(config.getInitParameter(paramName));\n    }\n    return null;\n}\n`"}
{"question": "Where in the Shiro web filter management module is the backing collection that the subList method delegates to initialized and populated?", "answer": "- The backing collection is a `List<Filter>` named `backingList`, initialized in constructors and defaulted to a new `ArrayList` when only a name is provided.\n`41:47:/data3/pwh/swebench-repos/java/shiro/web/src/main/java/org/apache/shiro/web/filter/mgt/SimpleNamedFilterList.java\nprivate List<Filter> backingList;\n...\npublic SimpleNamedFilterList(String name) {\n    this(name, new ArrayList<Filter>());\n}\n`\n`63:69:/data3/pwh/swebench-repos/java/shiro/web/src/main/java/org/apache/shiro/web/filter/mgt/SimpleNamedFilterList.java\npublic SimpleNamedFilterList(String name, List<Filter> backingList) {\n    if (backingList == null) { throw new NullPointerException(...); }\n    this.backingList = backingList;\n    setName(name);\n}\n`\n- Population occurs via the standard `List`-delegated mutators: `add`, `addAll`, indexed adds, and `set`.\n`86:100:/data3/pwh/swebench-repos/java/shiro/web/filter/mgt/SimpleNamedFilterList.java\npublic boolean add(Filter filter) { return this.backingList.add(filter); }\npublic void add(int index, Filter filter) { this.backingList.add(index, filter); }\npublic boolean addAll(Collection<? extends Filter> c) { return this.backingList.addAll(c); }\npublic boolean addAll(int index, Collection<? extends Filter> c) { return this.backingList.addAll(index, c); }\n`\n- The `subList` method delegates directly to this backing list.\n`166:168:/data3/pwh/swebench-repos/java/shiro/web/filter/mgt/SimpleNamedFilterList.java\npublic List<Filter> subList(int fromIndex, int toIndex) {\n    return this.backingList.subList(fromIndex, toIndex);\n}\n`"}
